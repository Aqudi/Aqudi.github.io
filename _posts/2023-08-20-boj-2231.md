---
title: "[BOJ] 2231 분해합"
author: Aqudi
aliases: []
categories: [algorithm]
tags: [BOJ]
date created: 2023-08-20 22:35:48+0900
date: 2023-09-07 23:18:46+0900
last_modified_at: 2023-09-07 23:53:08+0900
---
[https://www.acmicpc.net/problem/2292](https://www.acmicpc.net/problem/2292)

## 문제

어떤 자연수 N이 있을 때, 그 자연수 N의 분해합은 N과 N을 이루는 각 자리수의 합을 의미한다. 어떤 자연수 M의 분해합이 N인 경우, M을 N의 생성자라 한다. 예를 들어, 245의 분해합은 256(=245+2+4+5)이 된다. 따라서 245는 256의 생성자가 된다. 물론, 어떤 자연수의 경우에는 생성자가 없을 수도 있다. 반대로, 생성자가 여러 개인 자연수도 있을 수 있다.

자연수 N이 주어졌을 때, N의 가장 작은 생성자를 구해내는 프로그램을 작성하시오.
## 입력
첫째 줄에 자연수 N(1 ≤ N ≤ 1,000,000)이 주어진다.

## 출력
첫째 줄에 답을 출력한다. 생성자가 없는 경우에는 0을 출력한다.

## 예제 입력 1
```
216
```

## 예제 출력 1
```
198
```

## 풀이
시간 제한 2초에 입력의 범위가 100M이다. 알고리즘 문제 풀이에서 파이썬이 1초에 2000만 번의 연산이 가능하다고 가정하고 문제에 접근하는 것이 좋다고 한다. 실제로 이 문제는 `O(N^2)`의 시간복잡도를 가진 알고리즘으로는 시간 초과가 나고  `O(NlogN)` 알고리즘으로 풀이를 해야 풀렸다.

```python
N = int(input())
answer = 0
for i in range(N):
	# 분해합 계산
    digitSum = i + sum(map(int, str(i)))
    if N == digitSum:
        answer = i
        break
print(answer)
```

풀이 코드의 시간복잡도를 계산하면 다음과 같다.

- 분해합 계산의 시간복잡도는 `O(logN)`이다.
	- `sum(map(int, str(i)))`는 `i`의 자릿수 `d`에 영향을 받아 `O(d)`의 시간복잡도를 가진다. 
	- 자릿수 `d`는 10으로 몇 번 나눠지는지 계산으로 확인할 수 있으니 `log(i)`의 시간복잡도를 가진다. 최악의 경우에는 `N-1` 반복까지 수행되므로 `O(logN)`의 시간복잡도를 가진다.
- 이를 `N-1`번 반복하므로 총 시간복잡도는 `O(NlogN)`이다.

